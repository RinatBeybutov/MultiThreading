# Описание
Этот репозиторий создан для тестирования и демонстрации
многопоточного программирования

# CountDownLatchExample

CountDownLatch - это класс базовой библиотеки java, который имеет внутри себя
счетчик. В основном потоке программы можно ожидать до тех пор, пока этот счетчик не станет равным 0. 
А каждый запущенный поток в конце своей работы уменьшает этот счетчик на единицу.

Таким образом, после окончания всех потоков счетчик обнулится и код в главном потоке продолжится.

# IncrementProblem

Показывает базовую проблему совместного использования ресурса несколькими потоками.

Два потока обращаются к одному и тому же объекту типа Counter для инкремента счетчика.
Из-за многопоточного режима происходит перезапись переменной и возникает эффект потерянного обновления.

# ShipsConcurrent

1. Есть транспортные корабли, которые подплывают к туннелям и далее плывут к причалам для погрузки
разного рода товара.
2. Они проходят через узкий туннель где одновременно могут находиться только 5 кораблей.
Под словом “подплывают к туннелям” имеется в виду то, что корабли должны откуда-то появляться.
Их может быть ограниченное количество, то есть 10 или 100, а может быть бесконечное множество.
“Подплывают” назовем генератором кораблей.
Вид кораблей и их вместительность могут быть разными в зависимости от типа товаров, которые
нужно загрузить на корабль. 3 Типа кораблей (Хлеб, Банан и Одежда)
и три вида вместительности 10, 50, 100 шт. товаров. 3 типа кораблей * 3 вида вместительности = 9
разных видов кораблей.
3. Далее есть 3 вида причалов для погрузки кораблей — Хлеб, Банан и Одежда. Каждый причал берет или
подзывает к себе необходимый ему корабль и начинает его загружать. За одну секунду причал загружает
на корабль 10 ед. товара. То есть если у корабля вместительность 50 шт., то причал загрузит его
за 5 секунд своей работы.

Требование следующее:

1. Правильно разбить задачу на параллельность.
2. Синхронизировать потоки, сохранить целостность данных.
3. Работа генератора кораблей не должна зависеть от работы причалов и наоборот.
4. Общий ресурс должен быть Thread Safe (Если таковой есть в реализации)
5. Потоки не должны быть активными если нет задач.
6. Потоки не должны держать mutex если нет задач.

# ThreadStates

Этот код воспроизводит разные статусы потоков:
1. NEW
2. RUNNABLE
3. TIMED_WAITING
4. BLOCKED

# TrackingTaxi

Трекер такси для диспетчера автопарка
такси - string + position(x, y)

класс трекера потокобезопасен, ни один массив, ни какие-либо мутируемые точки не публикуются

Из-за синхронизации снижается производительность
